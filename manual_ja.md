# Nimマニュアル
原著：Andreas Rumpf, Zahary Karadjov  
原文：[https://nim-lang.org/docs/manual.html](https://nim-lang.org/docs/manual.html)  
Version：1.02  

## このドキュメントについて
注：このドキュメントはドラフトです！Nimの機能のいくつかには、より正確な表現が必要な場合があります。このマニュアルは常に適切な仕様に進化しています。 

注：Nimの実験的な機能については、[こちら](https://nim-lang.org/docs/manual_experimental.html)で説明しています。  

注：割り当て、移動、および破棄は、[デストラクタ](https://nim-lang.org/docs/destructors.html)ドキュメントで指定されています。  

このドキュメントでは、Nim言語の語彙、構文、およびセマンティクスについて説明します。  

Nimプログラムをコンパイルしてドキュメントを生成する方法については、[コンパイラユーザーガイド](https://nim-lang.org/docs/nimc.html)および
[DocGenツールガイド](https://nim-lang.org/docs/docgen.html)を参照してください。

言語構成要素は、拡張BNFを使用して説明されます。`(a)*`は0個以上の`a`を意味し、`a+`は1個以上の`a`を意味し、`(a)?`はオプショナルな`a`を意味します。
括弧を使用して要素をグループ化できます。

`&`は先読み演算子です。`&a`は、 `a`が期待されるが消費されないことを意味します。次のルールで消費されます。

`|`,`/`記号は代替をマークするために使用され、優先順位が最も低くなります。
`/`は、パーサーが指定された順序で代替を試行することを必要とする順序付けされた選択です。
`/`は、文法が曖昧にならないようにするためによく使用されます。

非終端記号は小文字で始まり、抽象終端記号は大文字です。逐語的な終端記号（キーワードを含む）は`'`で囲みます。  
例：`ifStmt = 'if' expr ':' stmts ('elif' expr ':' stmts)* ('else' stmts)?`

2項演算子`^*`は、2番目の引数で区切られた0個以上のオカレンス（訳者注：適切な訳が分からず）の省略形として使用されます。
同様に、`^+`は1つ以上のオカレンスを意味します。`a ^+ b`は`a (b a)*`の短縮形であり、`a ^* b`は`(a (b a)*)`の短縮形です。  
例：`arrayConstructor = '[' expr ^* ',' ']'`

スコープルールやランタイムセマンティクスなど、Nimの他の部分は非公式に説明されています。

## 定義(Definitions)
Nimコードは、locationと呼ばれるコンポーネントで構成されるメモリに作用する計算を詳記します。
変数は、基本的にlocationの名前です。各変数とlocationは特定のタイプです。
変数の型は静的型と呼ばれ、locationの型は動的型と呼ばれます。
静的タイプが動的タイプと同じでない場合、それは動的タイプのスーパータイプまたはサブタイプです。

識別子は、変数、型、プロシージャなどの名前として宣言されたシンボルです。
宣言が適用されるプログラムの領域は、宣言のスコープと呼ばれます。
スコープはネストできます。
識別子の意味は（オーバーロード解決規則が別の方法を示唆しない限り）識別子が宣言される最小の囲みスコープによって決定されます。

式は値またはlocationを生成する計算を詳記します。
locationを生成する式は左辺値と呼ばれます。
左辺値は文脈に応じて、locationまたはlocationに含まれる値のいずれかを示すことができます。

Nimプログラムは、Nimコードを含む1つ以上のテキストソースファイルで構成され、Nimコンパイラーによって実行可能ファイルに処理されます。
この実行可能ファイルの性質は、コンパイラの実装に依存します。（例：ネイティブバイナリ、JavaScriptソースコード）

典型的なNimプログラムでは、ほとんどのコードが実行可能ファイルにコンパイルされます。
ただし、一部のコードはコンパイル時に実行される場合があります。
これには、定数式、マクロ定義、およびマクロ定義で使用されるNimプロシージャを含めることができます。
ほとんどのNim言語はコンパイル時にサポートされますが、いくつかの制限があります。
詳細は[コンパイル時実行の制限](https://nim-lang.org/docs/manual.html#restrictions-on-compileminustime-execution)を参照。
ランタイムという用語は、コンパイル時実行と実行可能ファイルの実行の両方をカバーします。

コンパイラは、Nimソースコードを抽象構文木（AST）と呼ばれる内部データ構造に解析します。
次に、コード実行または実行可能ファイルにコンパイルする前に、セマンティック解析（意味解析）によりASTを変換します。
これにより、式のタイプ、識別子の意味、場合によっては式の値などのセマンティック情報が追加されます。
セマンティック分析中に検出されたエラーは、静的エラーと呼ばれます。
このマニュアルで説明されているエラーは、特に明記されていない限り静的エラーです。

チェックされたランタイムエラーは、実装により実行時に検出、報告されます。
このようなエラーを報告する方法は、例外を発生させるか、致命的なエラーで強制終了させることです。
ただし、実装はこれらのランタイムチェックを無効にする手段を提供します。詳細については、[Pragma](#Pragmas)セクションを参照してください。

チェックされたランタイムエラーの結果が例外になるか、致命的なエラーになるかは実装固有です。従って、次のプログラムは無効です。
コードが範囲外の配列アクセスから`IndexError`をキャッチすることを意図している場合でも、コンパイラは、プログラムが致命的なエラーで死ぬことを許可することを選択する場合があります。
```nim
var a: array[0..1, char]
let i = 5
try:
  a[i] = 'N'
except IndexError:
  echo "invalid index"
```

未確認のランタイムエラーは検出することを保証できず、その後の処理について想定外の結果となることがあります。
安全な言語機能のみが使用され、ランタイムチェックが無効になっていない場合、未チェックのランタイムエラーは発生しません。

定数式は、それが現れるコードのセマンティック解析中に値を計算できる式です。
左辺値でなく、副作用もありません。
定数式は、定数畳み込みなどのセマンティック解析の機能に制限されません。
コンパイル時の実行がサポートされている全てのNim言語機能を使用できます。
定数式は、セマンティック解析への入力として使用できるため（配列境界の定義など）、
この柔軟性のために、コンパイラはセマンティック解析とコンパイル時のコード実行をインターリーブする必要があります。

ソースコード内で上から下、左から右に進むセマンティック解析を想像し、その後のセマンティック分析に必要な値を計算するために必要なときにコンパイル時のコード実行をインターリーブすることは、ほとんど正確です。
このドキュメントの後半で、マクロの呼び出しではこのインターリーブが必要になるだけでなく、セマンティック解析が完全に上から下、左から右に進まない状況が生じることもわかります。

## 字句解析(Lexical Analysis)
### エンコーディング(Encoding)
すべてのNimソースファイルはUTF-8エンコーディング（またはそのASCIIサブセット）です。
他のエンコードはサポートされていません。
改行コードはLF(Unix)、CR+LF(Windows)、CR(古いMac)をプラットフォームに関係なく使用できます。

### インデント(Indentation)
Nimの標準文法においてインデントはとても重要です。
すべての制御構造がインデントによって認識されるからです。
インデントはスペースのみで構成され、タブは使用できません。

インデント処理は、次のように実装されます。
字句解析器は、後続のトークンにその前についているスペース数で注釈を付けます。
インデントは別個のトークンではありません。
この仕組みにより、先読みトークンを1つだけ使用してNimを解析できます。

パーサーは、インデントレベルのスタックを使用します。
スタックは、スペースをカウントする整数で構成されます。
インデント情報は、パーサーの戦略的な場所で照会されますが、そうでない場所では無視されます。
擬似終端`IND{>}`は、スタックの最上部のエントリよりも多くのスペースで構成されるインデントを示します。
`IND{=}`は、同じ数のスペースを持つインデントす示します。
`DED`は、スタックから値をポップするアクションを記述する別の疑似終端であり、
`IND{>}`はスタックへのプッシュを伴います。

この表記法により、文法の中核を簡単に定義できるようになりました。
ステートメントのブロック（簡単な例）
```
ifStmt = 'if' expr ':' stmt
         (IND{=} 'elif' expr ':' stmt)*
         (IND{=} 'else' ':' stmt)?

simpleStmt = ifStmt / ...

stmt = IND{>} stmt ^+ IND{=} DED  # list of statements
     / simpleStmt                 # or a simple statement
```

### コメント(Comments)
コメントは、文字列または文字リテラルの外側のどこからでもハッシュ記号`#`で始まります。
コメントはコメントピースの連結から成ります。
コメントピースは`#`から始まり、行の終わりまでです。
行末文字はコメントピースに属します。
次の行がコメントのみで構成されている場合、新しいコメントは開始されません。

```nim
i = 0     # これは複数行にまたがる単一のコメントです。
  # scannerはこれらコメントピースをマージします。
  # このコメントはここまでが一続きです
```
ドキュメントコメントは、`##`で始まるコメントです。
ドキュメントコメントはトークンであり、構文ツリーに属しているため、入力ファイルの特定の場所でのみ許可されます！

### 複数行コメント(Multiline comments)
Nimのバージョン0.13.0以降では複数行コメントができます。
例：
```nim
#[このように
複数行にわたって
コメントができます。]#
```
複数行コメントはネストができます。
```nim
#[  #[ Multiline comment in already
   commented out code. ]#
proc p[T](x: T) = discard
]#
```

複数行のドキュメントコメントも存在し、ネストもすることもできます。
```nim
proc foo =
  ##[Long documentation comment
  here.
  ]##
```

### 識別子とキーワード(Identifiers & Keywords)
Nimの識別子は、文字(letter)で始まり任意の文字(letter)、数字(digit)、アンダースコア`_`を組み合わせた文字列です。
連続したアンダースコア`__`は使用できません。
```nim
letter ::= 'A'..'Z' | 'a'..'z' | '\x80'..'\xff' #文字
digit ::= '0'..'9'#数字
IDENTIFIER ::= letter ( ['_'] (letter | digit) )* #一文字目は必ず文字（letter）である必要がある
```

現在、非ASCIIのUnicode文字(ordinal value > 127)は文字として分類されているため識別子に使えますが、言語の今後のバージョンで、Unicode文字が演算子に割り当てられる可能性があります。（訳者注：つまり、非ASCII文字を識別子に使うのは避けたほうが無難）

以下のキーワードは予約語であり、識別子として使用できません。
```
addr and as asm
bind block break
case cast concept const continue converter
defer discard distinct div do
elif else end enum except export
finally for from func
if import in include interface is isnot iterator
let
macro method mixin mod
nil not notin
object of or out
proc ptr
raise ref return
shl shr static
template try tuple type
using
var
when while
xor
yield
```
一部のキーワードは使用されていませんが、将来の言語開発のために予約されています。

### 識別子の等価性(Identifier equality)
次のアルゴリズムが真のとき、2つの識別子は等しいとみなされます。
```nim
proc sameIdentifier(a, b: string): bool =
  a[0] == b[0] and
    a.replace("_", "").toLowerAscii == b.replace("_", "").toLowerAscii
```
つまり、最初の文字のみ大文字と小文字を区別して比較されます。
他の文字はASCII範囲内で大文字と小文字を区別せずに比較され、アンダースコアは無視されます。

識別子の比較を行うこのかなり非正統的な方法は、partial case insensitivityと呼ばれ、従来の大文字と小文字を区別するよりもいくつかの利点があります。
これにより、プログラマーはhumpStyleでもsnake_styleでも、好みのスペルスタイルをほとんど使用でき、異なるプログラマーによって作成されたライブラリは互換性のない規則を使用できません。
Nim対応のエディターまたはIDEは、必要に応じて識別子を表示できます。
もう1つの利点は、プログラマーを識別子の正確なスペルを覚えることから解放することです。
最初の文字に関する例外により、`var foo:Foo`のような一般的なコードを明確に解析できます。

このルールにより、`notin`が`notIn`と`not_in`が同じ意味を持つことに注意して下さい。
（すべて小文字にすること(`notin`,`isnot`)がキーワードの好ましい記述法です）。

歴史的に、Nimは完全にスタイルに依存しない言語でした。
これは、大文字と小文字が区別されず、アンダースコアが無視され、fooとFooの区別さえないことを意味していました。

### 文字列リテラル(String literals)
文法の終端記号:`STR_LIT`

文字列リテラルは、ダブルクォーテーション`"`で囲まれ、以下のエスケープシーケンスを含めることができます。

|Escape<br>sequence|Meaning|
|:---|:---|
|`\p`|プラットフォーム固有の改行：WindowsではCRLF、UnixではLF|
|`\r`,`\c`|キャリッジリターン(carriage return)|
|`\n`,`\l`|line feed(よくnewlineとよばれる)|
|`\f`|form feed|
|`\t`|タブ(tabulator)|
|`\v`|垂直タブ(vertical tabulator)|
|`\\`|バックスラッシュ(backslash)|
|`\"`|クォーテーションマーク(quotation mark)|
|`\'`|アポストロフィ(apostrophe)|
|`\`'0'...'9'+|10進値dを持つ文字、`\`の直後に連続するすべての10進数の数字が使用されます|
|`\a`|アラート(alert)|
|`\b`|バックスペース(backspace)|
|`\e`|エスケープ(escape) [ESC]|
|`\x`HH|16進値HHを持つ文字。正確に2桁の16進数が許可されます|
|`\u`HHHH|16進値HHHHを持つUnicodeコードポイント。正確に4桁の16進数が許可されます|
|`\u`{H+}|Unicodeコードポイント。`{}`で囲まれたすべての16進数がコードポイントに使用されます|

Nimの文字列には、ゼロが埋め込まれていても8ビット値を含めることができます。ただし、一部の操作では、最初のバイナリゼロが終端として解釈される場合があります。

### 三重引用符付き文字列リテラル(Triple quoted string literals)
文法の終端記号:`TRIPLESTR_LIT`

文字列リテラルは、3つのダブルクォーテーション`"""`...`"""`で囲むこともできます。
この形式の文字列リテラルは複数行にまたがることができ、`"`を含むことができ、エスケープシーケンスを解釈しません。
便宜上、開始側の`"""`の後に改行が続く場合（`"""`と改行の間に空白がある場合もあります）、改行（およびその前の空白）は文字列に含まれません。
文字列リテラルの末尾は、パターン`"""[^"]`で定義されます。
そのため、
```nim
""""long string within quotes""""
```
は
```
"long string within quotes"
```
を表します。

### 生文字列リテラル(Raw string literals)
文法の終端記号:`RSTR_LIT`

`r`(または`R`)で始まり、通常の文字列リテラルと同様に`"`で囲まれた生文字列リテラルも使用できます。
これはエスケープシーケンスを解釈せず、正規表現やWIndowsパスを表すのに特に便利です。
```nim
var f = openFile(r"C:\texts\text.txt") # 生文字列なので"\t"はタブではありません
```
生文字列リテラル内で`"`を表すには2つ並べる必要があります。
```nim
r"a""b"
```
は
```
a"b
```
を意味します。

この表記法では`r""""`は使用できません。
それは3連続の`"`は三重引用符付き文字列リテラルとなるからです。
三重引用符付き文字列リテラルはエスケープシーケンスを解釈しないため、`r"""`は`"""`と同じになります。

### 一般化生文字列リテラル(Generalized raw string literals)
文法の終端記号：`GENERALIZED_STR_LIT`,`GENERALIZED_TRIPLESTR_LIT`

`idenfier"stringliteral"`構文(識別子(identifier)と`"`の間に空白なし)は一般化生文字列リテラルです。
これは`identifier(r"string literal")`の短縮形であり、生文字列リテラルを唯一の引数とするプロシージャ呼び出しを表します。
一般化生文字列リテラルはミニ言語を直接Nimに埋め込むのに便利です。（例えば、正規表現）

`idenfier"""stringliteral"""`構文も存在します。これは`idenfier("""stringliteral""")`の短縮形です。

### 文字リテラル(Character literals)
文字リテラルは`'`で囲まれ、文字列と同じエスケープシーケンスを含むことができます。
ただし、プラットフォーム依存の改行(`\p`)は、1文字よりも多くなることがあるため(CR+LFなど)除外されます。
文字リテラルの有効なエスケープシーケンスは次のとおりです。

|Escape<br>sequence|Meaning|
|:---|:---|
|`\r`,`\c`|キャリッジリターン(carriage return)|
|`\n`,`\l`|line feed(よくnewlineとよばれる)|
|`\f`|form feed|
|`\t`|タブ(tabulator)|
|`\v`|垂直タブ(vertical tabulator)|
|`\\`|バックスラッシュ(backslash)|
|`\"`|クォーテーションマーク(quotation mark)|
|`\'`|アポストロフィ(apostrophe)|
|`\`'0'...'9'+|10進値dを持つ文字、`\`の直後に連続するすべての10進数の数字が使用されます|
|`\a`|アラート(alert)|
|`\b`|バックスペース(backspace)|
|`\e`|エスケープ(escape) [ESC]|
|`\x`HH|16進値HHを持つ文字。正確に2桁の16進数が許可されます|

文字(character)はユニコード文字ではなく、1バイトです。
この理由は効率性です：圧倒的多数のユースケースのために、UTF-8は特別に設計されているため、結果のプログラムは依然としてUTF-8を適切に処理します。
もう1つの理由は、多くのアルゴリズムが依存している`array[char,int]`または`set[char]`を効率的にサポートできるからです。
`Rune`型はUnicode文字のために用いられ、任意のUnicode文字を表すことができます。
`Rune`は[unicodeモジュール](https://nim-lang.org/docs/unicode.html)で宣言されています。






## Pragmas






